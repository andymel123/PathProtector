<!DOCTYPE HTML>
<html>
	<head>
		<!-- for painting the charts -->
		<script src="js/Chart.js"></script>
		
		<!-- for writing the time-labels in the chart (x-axis) -->
		<script src="js/date.min.js"></script>
		
		<!-- jquery for bootstrap -->
		<script src="js/jquery-3.2.1.js"></script>

		<!-- bootstrap (for folding) -->
		<link href="css/bootstrap.css" rel="stylesheet">
   		<script src="js/bootstrap.js"></script>


		<style type="text/css">
			    body{
			     	color: #333;
			     	font-family: Arial, Helvetica, sans-serif;
			    }
			    #wrapper {
/* 				  margin-right: 700px; */
					width: 100%;
				}
				#chartContainer{
 					max-height: 90vh; 
				}
				canvas{
					
				}
				#menuContainer{
					background-color: #CCC;
				}
				
				input[aria-expanded="true"]{
					font-weight: bold;
					background-color: #90ff90;
				}
				
		</style>
		
	</head>
	
	<body>
		<p id="pDescription"></p>
		<div class="container" id="wrapper">
			<div class="row">
				<div id="menuContainer" class="col-sm-2">
					<ul id="chartsMenu"></ul>
				</div>
				<div id="chartContainer" class="col-sm-10"></div>
			</div>
		</div>
		
		<script type="text/javascript">
		
			var chartsContainer = document.getElementById("chartContainer");
			var ulChartsMenu = document.getElementById("chartsMenu");
	    	
			var canvas = document.getElementById("cvs"); 
			var websocket;
			var charts = {};
			var chartDivs = {};
			
// 			initChart();
			
			openWebsocket();
		
			function openWebsocket(){
				
				websocket = new WebSocket(getWebSocketPath());

				websocket.onopen = function(event) {
					sendTextToServer("Connected with "+JSON.stringify(get_browser()));
					sendTextToServer("GetAllHashes");
				};

				websocket.onmessage = function(event) {
					var msg = JSON.parse(event.data);
// 					console.log(msg);
					handleServerEvent(msg);
				}

			}

			function getWebSocketPath(){
				// inspired by http://stackoverflow.com/a/10418013
				var loc = window.location, new_uri;
				if (loc.protocol === "https:") {
				    new_uri = "wss:";
				} else {
				    new_uri = "ws:";
				}
				new_uri += "//" + loc.host;
				new_uri += "/ws/v1";
				return new_uri;
			}
			
			function sendTextToServer(txt) {
				if(!websocket)return;
				// Send the msg object as a JSON-formatted string.
				websocket.send(JSON.stringify({
					type : "message",
					text : txt,
					date : Date.now()
				}));
			}

			function closeWebsocket(){
				if(!websocket)return;
				websocket.close();
			}
			
			function handleServerEvent(msg){
				switch (msg.type) {
					case "fulldata": {
						
						// website layout (add one canvas per chart data if not already there)
						initCharts(msg.hashes);
						
						// update overall description
						document.getElementById("pDescription").innerHTML = msg.description;
						
 						// update all charts
						var graphsArray = msg.graphData;
						for (i = 0; i < graphsArray.length; ++i) {
						    var graphData = graphsArray[i];
					
 						    // TODO write/update chart description

 						    document.getElementById("pDescription").innerHTML = graphData.description;  
 							   
							// update the right chart
							var hashId = getIdFromHash(graphData.hash);
							
							if(chartDivs[hashId].attr("aria-expanded")){
								// only if currently visible
								var chartOfHash = charts[hashId];
								if(chartOfHash && chartOfHash.data){
								    chartOfHash.data.labels = convertLabels(graphData.labels);
									chartOfHash.data.datasets = graphData.datasets;
									chartOfHash.update();
								}else{
									console.error("chart of hash '"+hashId+" is not valid!", chartOfHash);
								}
							}
						}		
						break;
					}
				}

			}
			
			function getIdFromHash(hash){
				return "cvs"+hash;
			}
			
			function initCharts(hashesArray) {
				
				for (i = 0; i < hashesArray.length; ++i) {
				    var hashId = getIdFromHash(hashesArray[i]);
					
				    var canvas = document.getElementById(hashId);
				    if(canvas){
				    	// we alread have a chart for this path
				    	continue;
				    }else{

				    	// menu
						var li = document.createElement("li");
// 						var cbId = "cb_"+hashId;
// 						var cb = $('<input />', { type: 'checkbox', id: cbId, value: hashId });
// 						cb.attr("data-toggle", "collapse");
// 						cb.attr("data-target", hashId);
// 						cb.appendTo(li);
// 						$('<label />', { 'for': cbId, text: hashId }).appendTo(li);
						$('<input/>')
							.attr({
						        type: "button",
						        id: "btn_"+hashId,
						        value: hashId,
						        "data-toggle": "collapse",
						        "data-target": "#div_"+hashId
						    })
						    .appendTo(li);
					    ulChartsMenu.appendChild(li);

					    
					    // div
				    	var divCvs = $('<div/>', {'class':'collapse'})
							.attr({
						        id: "div_"+hashId
						    })
						    .appendTo(chartsContainer);
				    	
				    	var newCanvas = 
				    	    $('<canvas/>')
				    	    .attr("id", hashId)
				    	    .width(2000)
				    	    .height(400)
				    		.appendTo(divCvs);
				    	
				    	var canvas = newCanvas[0];
				    	
// 				    	var canvas = document.createElement('canvas');
// 						chartsContainer.appendChild(canvas);
// 				    	canvas.id = hashId;
// 				    	canvas.width = 2000;
// 				    	canvas.height= 400;
				    	
// 				    	 class="collapse"
				    	 
						var ctx = canvas.getContext("2d");
						var data = {
							labels: [],
							datasets: []
						};

						var barchart = new Chart(ctx, {
							type : 'bar',
							data : data,
							options : {
								legend: {
							        display: false,
							        position: "left",
							        labels:{
							        	fontSize: 8
							        }
							    },
								animation:false,
								scales : {
									responsive : true,
									maintainAspectRatio : false,
									xAxes : [ {
										stacked : true
									} ],
									yAxes : [ {
										stacked : true,
										ticks : {
											beginAtZero : true
										}
									} ]
								}
							}
						});
						// save chart in dictonary
						charts[hashId] = barchart;
						chartDivs[hashId] = divCvs;
						
						// finally append the new canvas into the chartsContainer
				    }
				}
			}
			
			function convertLabels(msg_labels){
				return msg_labels.map(function(ms){
					var d = new Date(ms);
					var sep=":";
					var s = d.getUTCHours();
					s+=sep;
					s+=d.getUTCMinutes();
					s+=sep;
					s+=d.getSeconds();
					s+=sep;
					s+=d.getMilliseconds();
					return s;
				})
			}
			
			function get_browser() {
				// from http://stackoverflow.com/a/16938481
			    var ua=navigator.userAgent,tem,M=ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || []; 
			    if(/trident/i.test(M[1])){
			        tem=/\brv[ :]+(\d+)/g.exec(ua) || []; 
			        return {name:'IE',version:(tem[1]||'')};
			        }   
			    if(M[1]==='Chrome'){
			        tem=ua.match(/\bOPR|Edge\/(\d+)/)
			        if(tem!=null)   {return {name:'Opera', version:tem[1]};}
			        }   
			    M=M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
			    if((tem=ua.match(/version\/(\d+)/i))!=null) {M.splice(1,1,tem[1]);}
			    return {
			      name: M[0],
			      version: M[1]
			    };
			 }
			
		</script>
	</body>
</html>